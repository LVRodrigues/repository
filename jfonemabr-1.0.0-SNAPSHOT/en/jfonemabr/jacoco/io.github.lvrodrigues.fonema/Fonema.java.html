<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Fonema.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jfonemabr</a> &gt; <a href="index.source.html" class="el_package">io.github.lvrodrigues.fonema</a> &gt; <span class="el_source">Fonema.java</span></div><h1>Fonema.java</h1><pre class="source lang-java linenums">package io.github.lvrodrigues.fonema;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Implementação do algorítimo BuscarBR para pesquisa fonética no idioma português.
 *
 * @author $Criado por: LVRodrigues$
 * @author $Alterado por: LVRodrigues$
 * @version $Ramo: feature/site$
 * @see &lt;a href=&quot;https://github.com/LVRodrigues/jfonemabr/blob/main/docs/NOVOB.pdf&quot;&gt;NOVOB.pdf&lt;/a&gt;
 */
public final class Fonema {

    /**
     * Lista de caracteres acentuados que devem ser substituidos.
     *
     * &lt;p&gt;Como o primeiro passo para obter o fonema é passar o texto para maiúsculo,
     * não há necessidade de tratar os caracteres minúsculos acentuados.
     *
     * &lt;p&gt;A primeira dimensão possui a lista de caracteres acentuados. A segunda
     * dimensão poussui os caracteres de substituição.
     */
<span class="fc" id="L25">    private static final char[][] INVALID_CHARS = {</span>
        {
            'Á', 'É', 'Í', 'Ó', 'Ú',
            'À', 'È', 'Ì', 'Ò', 'Ù',
            'Â', 'Ê', 'Î', 'Ô', 'Û',
            'Ã', 'Ẽ', 'Ĩ', 'Õ', 'Ũ',
            'Ä', 'Ë', 'Ï', 'Ö', 'Ü',
            'Ç', 'Ÿ', 'Ý', 'Ñ'
        },
        {
            'A', 'E', 'I', 'O', 'U',
            'A', 'E', 'I', 'O', 'U',
            'A', 'E', 'I', 'O', 'U',
            'A', 'E', 'I', 'O', 'U',
            'A', 'E', 'I', 'O', 'U',
            'C', 'Y', 'Y', 'N'
        }
    };

    /**
     * Índice da coluna de pesquisa da matriz de caracteres inválidos.
     */
    private static final int INVALID_SEARCH_INDEX   = 0;

    /**
     * Índice da coluna de troca de valores da matriz de caracteres inválidos.
     */
    private static final int INVALID_REPLACE_INDEX  = 1;

    /**
     * Expressão regular para ignorar os caracteres de A até Z e de 0 (zero) até 9 (nove)
     * e remover os demais caracteres.
     */
<span class="fc" id="L58">    private static final Pattern INVALID_PATTERN = Pattern.compile(&quot;[^A-Z0-9\s]&quot;);</span>

    /**
     * Conjunto de expressões regulares (primeira dimensão) e seus caracteres de 
     * substituição (segunda dimensão).
     */
    @SuppressWarnings(&quot;MultipleStringLiterals&quot;)
<span class="fc" id="L65">    private static final Object[][] REPLACES = {</span>
<span class="fc" id="L66">        {Pattern.compile(&quot;(BL|BR)&quot;),                    &quot;B&quot;},</span>
<span class="fc" id="L67">        {Pattern.compile(&quot;(PH)&quot;),                       &quot;F&quot;},</span>
<span class="fc" id="L68">        {Pattern.compile(&quot;(GL|GR|MG|NG|RG)&quot;),           &quot;G&quot;},</span>
<span class="fc" id="L69">        {Pattern.compile(&quot;Y&quot;),                          &quot;I&quot;},</span>
<span class="fc" id="L70">        {Pattern.compile(&quot;(GE|GI|RJ|MJ)&quot;),              &quot;J&quot;},</span>
<span class="fc" id="L71">        {Pattern.compile(&quot;(CA|CO|CU|CK)|Q&quot;),            &quot;K&quot;},</span>
<span class="fc" id="L72">        {Pattern.compile(&quot;N&quot;),                          &quot;M&quot;},</span>
<span class="fc" id="L73">        {Pattern.compile(&quot;(AO|AUM|GM|MD|OM)&quot;),          &quot;M&quot;},</span>
<span class="fc" id="L74">        {Pattern.compile(&quot;(PR)&quot;),                       &quot;P&quot;},</span>
<span class="fc" id="L75">        {Pattern.compile(&quot;L&quot;),                          &quot;R&quot;},</span>
<span class="fc" id="L76">        {Pattern.compile(&quot;(CE|CI|CH|CS|RS|TS|X|Z)&quot;),    &quot;S&quot;},</span>
<span class="fc" id="L77">        {Pattern.compile(&quot;(TR|TL)&quot;),                    &quot;T&quot;},</span>
<span class="fc" id="L78">        {Pattern.compile(&quot;(CT|RT|ST|PT)&quot;),              &quot;T&quot;},</span>
<span class="fc" id="L79">        {Pattern.compile(&quot;W|\\bU&quot;),                     &quot;V&quot;},</span>
<span class="fc" id="L80">        {Pattern.compile(&quot;RM&quot;),                         &quot;SM&quot;},</span>
<span class="fc" id="L81">        {Pattern.compile(&quot;[MRS]\\b&quot;),                   &quot;&quot;},</span>
<span class="fc" id="L82">        {Pattern.compile(&quot;[AEIOUH]&quot;),                   &quot;&quot;}</span>
    };

    /**
     * Índice da coluna de expressões regulares para pesquisa de fonemas.
     */
    private static final int REPLACE_PATTERN_INDEX    = 0;

    /**
     * Índice da coluna de troca de valores para a pesquisa de fonemas.
     */
    private static final int REPLACE_VALUE_INDEX      = 1;

    /**
     * Construtor oculto, tornando uma classe utilitária.
     */
    private Fonema() {
    }

    /**
     * Processa um texto aplicando as regras do algorítimo BuscarBR.
     *
     * @param text Texto para extrair os fonemas.
     * @return Fonemas.
     */
    public static String process(final String text) {
        // 1. Converter para maiúsculas.
<span class="fc" id="L109">        String result = text.toUpperCase();</span>
        // 2. Remover caracteres especiais e acentos:
<span class="fc" id="L111">        result = clean(result);</span>
        // 3. Trocar dados por letras de fonéticas:
<span class="fc" id="L113">        result = replaces(result);</span>
        // 4. Remover caracteres duplicados consecutivamente.
<span class="fc" id="L115">        result = duplicates(result);</span>
        // 5. Remover vogais? Realizado no final do passo 3 utilizando expressões regulares.
<span class="fc" id="L117">        return result;</span>
    }    

    /**
     * Remove caracteres duplicados consecutivamente.
     *
     * @param text Texto para processar.
     * @return Fonema.
     */
    private static String duplicates(final String text) {
<span class="fc" id="L127">        char current                = 0;</span>
<span class="fc" id="L128">        final StringBuilder result  = new StringBuilder();</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">        for (char c : text.toCharArray()) {</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">            if (current != c) {</span>
<span class="fc" id="L131">                result.append(c);</span>
            }
<span class="fc" id="L133">            current = c;</span>
        }
<span class="fc" id="L135">        return result.toString();</span>
    }

    /**
     * Troca letras baseadas em expressões regulares.
     *
     * @param text Texto para manipular.
     * @return Texto manipulado.
     */
    private static String replaces(final String text) {
<span class="fc" id="L145">        String result = text;</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">        for (int i = 0; i &lt; REPLACES.length; i++) {</span>
<span class="fc" id="L147">            final Matcher matcher   = ((Pattern) REPLACES[i][REPLACE_PATTERN_INDEX]).matcher(result);</span>
<span class="fc" id="L148">            result                  = matcher.replaceAll((String) REPLACES[i][REPLACE_VALUE_INDEX]);</span>
        }
<span class="fc" id="L150">        return result;</span>
    }

    /**
     * Limpa os caracteres acentuados e especiais do texto.
     *
     * @param text Texto para ser limpo.
     * @return Texto manipulado.
     */
    private static String clean(final String text) {
<span class="fc" id="L160">        String result = text;</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        for (int i = 0; i &lt; INVALID_CHARS[INVALID_SEARCH_INDEX].length; i++) {</span>
<span class="fc" id="L162">            result = result.replace(INVALID_CHARS[INVALID_SEARCH_INDEX][i], </span>
                                    INVALID_CHARS[INVALID_REPLACE_INDEX][i]);
        }
        // Removendo os demais caracteres especiais:
<span class="fc" id="L166">        final Matcher matcher = INVALID_PATTERN.matcher(result);</span>
<span class="fc" id="L167">        return matcher.replaceAll(&quot;&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>